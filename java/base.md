# JDK，JRE，JVM的作用和关系
## 作用：
### JDK：Java程序的开发环境
### JRE：JAVA程序的运行环境
### JVM：保证Java语言的跨平台性，也就是说不同的平台提供不同的JVM，才使得Java跨平台。
## 关系：
### JDK：JRE+工具
### JRE：JVM+类库

# Java基础语法
## 关键字
### 概述：
被Java语言赋予特定含义的单词
### 特点：
组成关键字的字母全部小写
### 注意事项
goto和const作为保留字存在,目前并不使用
## 标识符
### 概述：
就是给类,接口,方法,变量等起名字时使用的字符序列
### 组成规则：
* 英文大小写字母
* 数字字符
* $和_
### 注意事项：
* 不能以数字开头
* 不能是Java中的关键字
* 区分大小写
## 注释
### 概述：
用于解释说明程序的文字
### Java中注释分类格式
* 单行注释：// 注释文字
* 多行注释：/* 注释文字 */
* 文档注释：/** 注释文字 */
## 常量
### 概述：
在程序执行的过程中其值不可以发生改变
### 字面值常量：
* 字符串常量 "hello"
* 整数常量	12,23
* 小数常量	12.345
* 字符常量	'a','A','0'
* 布尔常量	true,false
* 空常量	null(后面讲)
### 整数常量提供了四种表现形式
* 二进制	由0，1组成。以0b开头
* 八进制	由0，1，...7组成。以0开头。
* 十进制	由0，1，...9组成。整数默认是十进制
* 十六进制	由0，1，...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。
### 有符号数据表示法
在计算机内，有符号数有3种表示法：原码、反码和补码。所有数据的运算都是采用补码进行的
* 原码：就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小
* 反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外
* 补码：正数的补码与其原码相同；负数的补码是在其反码的末位加1
## 变量
### 概述：
在程序执行的过程中，在某个范围内其值可以发生改变的量，从本质上讲，变量其实是内存中的一小块区域，
使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请（声明），然后必须进行赋值（填充内容），才能使用。
### 变量定义格式
数据类型 变量名 = 初始化值
## 数据类型
Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存总分配了不同大小的内存空间.
![java数据类型](https://raw.githubusercontent.com/XXXu/imgbed/master/img/20200517174007.png)
## 运算符
* 算术运算符
* 赋值运算符
* 比较运算符
* 逻辑运算符
* 位运算符
* 三目运算符
## 流程控制语句
* 顺序结构：是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的
* 选择结构：也称分支结构
    * if语句
    * switch语句
* 循环结构：循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环
    * for循环
    * while循环
    * do...while循环
## 跳转控制语句
### break
#### 使用场景
* 在选择结构switch语句中
* 在循环语句中
#### 作用
* 跳出单层循环
* 跳出多层循环：带标签的跳出
### continue：在循环语句中
#### 作用
单层循环对比break，然后总结两个的区别：
* break：退出当前循环
* continue：退出本次循环
### return
return关键字不是为了跳转出循环体，更常用的功能是结束一个方法，也就是退出一个方法。跳转到上层调用的方法。这个在方法的使用那里会在详细的讲解
## 方法
### 定义：
简单的说：方法就是完成特定功能的代码块
## 方法重载
### 概述：
在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
### 特点：
* 与返回值类型无关，只看方法名和参数列表
* 在调用时，虚拟机通过参数列表的不同来区分同名方法
## 数组
### 概念：
* 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器
* 数组既可以存储基本数据类型，也可以存储引用数据类型
## Java中的内存分配
Java 程序在运行时，需要在内存中的分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式
* 栈 存储局部变量
* 堆 存储new出来的东西
* 方法区 (面向对象部分讲)
* 本地方法区 (和系统相关)
* 寄存器 (给CPU使用)
## 面向对象
### 开发
就是不断的创建对象，使用对象，指挥对象做事情
### 设计
其实就是在管理和维护对象之间的关系
### 特征
* 封装
* 继承
* 多态
## 类与对象关系
* 类：是一组相关的属性和行为的集合
* 对象：是该类事物的具体体现
* 举例：
    * 类：学生
    * 对象：班长就是一个对象
## 成员变量和局部变量的区别
### 在类中的位置不同
* 成员变量 类中方法外
* 局部变量 方法内或者方法声明上
### 在内存中的位置不同
* 成员变量 堆内存
* 局部变量 栈内存
### 生命周期不同
* 成员变量 随着对象的存在而存在，随着对象的消失而消失
* 局部变量 随着方法的调用而存在，随着方法的调用完毕而消失
### 初始化值不同
* 成员变量 有默认的初始化值
* 局部变量 没有默认的初始化值，必须先定义，赋值，才能使用
## 匿名对象
就是没有名字的对象
### 使用情况
* 对象调用方法仅仅一次的时候
* 作为实际参数传递
## 封装
### 概述
是指隐藏对象的属性和实现细节，仅对外提供公共访问方式
### 好处
* 隐藏实现细节，提供公共的访问方式
* 提高了代码的复用性
* 提高安全性
### 原则
* 将不需要对外提供的内容都隐藏起来
* 把属性隐藏，提供公共方法对其访问
## private关键字
* 可以修饰成员（成员变量和成员方法）
* 被private修饰的成员只在本类中才能访问
## this关键字
* this：代表所在类的对象引用，方法被哪个对象调用，this就代表那个对象
* 什么时候使用this呢？
    * 局部变量隐藏成员变量
    * 其他用法后面和super一起讲解
## 构造方法
### 概述
给对象的数据进行初始化
### 格式
* 方法名与类名相同
* 没有返回值类型，连void都没有
* 没有具体的返回值
### 注意事项
* 如果你不提供构造方法，系统会给出默认构造方法
* 如果你提供了构造方法，系统将不再提供
* 构造方法也是可以重载的
## 类的初始化过程
`Student s = new Student()`
在内存中做了哪些事情？
* 加载Student.class文件进内存
* 在栈内存为s开辟空间
* 在堆内存为学生对象开辟空间
* 对学生对象的成员变量进行默认初始化
* 对学生对象的成员变量进行显示初始化
* 通过构造方法对学生对象的成员变量赋值
* 学生对象初始化完毕，把对象地址赋值给s变量
## static关键字
* 可以修饰成员变量和成员方法
* 特点：
    * 随着类的加载而加载
    * 优先于对象存在
    * 被类的所有对象共享：这也是我们判断是否使用static关键字的条件
    * 可以通过类名调用
* 注意事项
    * 在静态方法中是没有this关键字的
    * 静态方法只能访问静态的成员变量和静态的成员方法
## 代码块
在Java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)
* 局部代码块
在方法中出现；限定变量生命周期，及早释放，提高内存利用率
* 构造代码块
在类中方法外出现，多个构造方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行
* 静态代码块
在类中方法外出现，加了static修饰，用于给类进行初始化，在加载的时候就执行，并且只执行一次
## 继承
### 概述
* 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。
* 通过extends关键字可以实现类与类的继承
* 单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类
* 有了继承以后，我们定义一个类的时候，可以在一个已经存在的类的基础上，还可以定义自己的新成员
### 特点
* Java只支持单继承，不支持多继承
* Java支持多层继承(继承体系)
### 注意事项
* 子类只能继承父类所有非私有的成员(成员方法和成员变量，其实这也体现了继承的另一个弊端，打破了封装性)
* 子类不能继承父类的构造方法，但是可以通过super(后面讲)关键字去访问父类构造方法
* 不要为了部分功能而去继承
* 我们到底在什么时候使用继承呢？（继承中类之间体现的是：”is a”的关系）
## super关键字
* super的用法和this很像
    * this代表本类对应的引用
    * super代表父类存储空间的标识（可以理解为父类引用）
* 用法
    * 访问成员变量: this.成员变量 super.成员变量
    * 访问构造方法 this(...) super(...)
    * 访问成员方法: this.成员方法 super.成员方法
## 继承中构造方法的关系
子类中所有的构造方法默认都会访问父类中空参数的构造方法
* 为什么？
    * 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。
    * 每一个构造方法的第一条语句默认都是：super()
* 如何父类中没有构造方法，该怎么办呢?
    * 子类通过super去显示调用父类其他的带参的构造方法
    * 子类通过this去调用本类的其他构造方法，本类其他构造也必须首先访问了父类构造
    * super(...)或者this(...)必须出现在第一条语句。
## 继承中成员方法的关系
* 结论：通过子类对象去访问一个方法，首先在子类中找，然后在父类中找。
* 方法重写：子类中出现了和父类中一模一样的方法声明，也被称为方法覆盖，方法复写。
* 方法重写的应用：当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容
* 注意事项
    * 父类中私有方法不能被重写
    * 子类重写父类方法时，访问权限不能更低
    * 父类静态方法，子类也必须通过静态方法进行重写。(其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解)
## final关键字
* final关键字是最终的意思，可以修饰类，成员变量，成员方法。
    * 修饰类，类不能被继承
    * 修饰变量，变量就变成了常量，只能被赋值一次
    * 修饰方法，方法不能被重写
## 多态
### 概述
    * 某一个事物，在不同时刻表现出来的不同状态
    * 举例：
        * 猫可以是猫的类型。猫 m = new 猫();
        * 同时猫也是动物的一种，也可以把猫称为动物。动物 d = new 猫();
### 多态前提和体现
    * 有继承关系
    * 有方法重写
    * 有父类引用指向子类对象
### 成员访问特点 （动物 d = new 猫()）
    * 成员变量：编译看左边，运行看左边
    * 成员方法：编译看左边，运行看右边
    * 静态方法：编译看左边，运行看左边，所以前面我说静态方法不能算方法的重写。
### 多态的好处和弊端
    * 好处：
        * 提高了程序的维护性(由继承保证)
        * 提高了程序的扩展性(由多态保证)
    * 弊端：
        * 不能访问子类特有功能
        * 那么我们如何才能访问子类的特有功能呢？（多态中的转型）
### 多态中的转型问题
    * 向上转型
        * 从子到父
        * 父类引用指向子类对象
    * 向下转型
        * 从父到子
        * 父类引用转为子类对象
## 抽象类
### 概述
在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。
### 特点
* 抽象类和抽象方法必须用abstract关键字修饰
* 抽象类不一定有抽象方法，有抽象方法的类一定是抽象类
* 抽象类不能实例化：按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。
* 抽象类的子类
    * 要么是抽象类
    * 要么重写抽象类中的所有抽象方法
### 成员特点
* 成员变量
    * 可以是变量
    * 也可以是常量
* 构造方法
    * 有构造方法，但是不能实例化
    * 那么，构造方法的作用是什么呢？用于子类访问父类数据的初始化
* 成员方法
    * 可以有抽象方法 限定子类必须完成某些动作
    * 也可以有非抽象方法 提高代码复用性
## 接口
### 特点
* 接口用关键字interface表示
* 类实现接口用implements表示
* 接口不能实例化
    * 那么，接口如何实例化呢?
    * 按照多态的方式，由具体的子类实例化。其实这也是多态的一种，接口多态
* 接口的子类
    * 要么是抽象类
    * 要么重写接口中的所有抽象方法
## 成员特点
* 成员变量
    * 只能是常量
    * 默认修饰符 public static final
* 构造方法
    * 没有，因为接口主要是扩展功能的，而没有具体存在
* 成员方法
    * 只能是抽象方法
    * 默认修饰符 public abstract
## 类与接口关系
* 类与类：继承关系，只能单继承，但是可以多层继承
* 类与接口：实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口
* 接口与接口：继承关系，可以单继承，也可以多继承
## 抽象类和接口的区别
* 成员区别
    * 抽象类 变量,常量;有抽象方法;抽象方法,非抽象方法
    * 接口 常量;抽象方法
* 关系区别
    * 类与类 继承，单继承
    * 类与接口 实现，单实现，多实现
    * 接口与接口 继承，单继承，多继承
* 设计理念的区别：
    * 抽象类 被继承体现的是：”is a”的关系。共性功能
    * 接口 被实现体现的是：”like a”的关系。扩展功能
## 包
### 概述
* 其实就是文件夹
* 作用：对类进行分类管理
* 定义包的格式
    * package 包名，多级包用.分开即可
    * 注意事项
        * package语句必须是程序的第一条可执行的代码
        * package语句在一个java文件中只能有一个
        * 如果没有package，默认表示无包名
* 权限修饰符
    ![](https://raw.githubusercontent.com/XXXu/imgbed/master/img/20200523193218.png)
## 内部类
### 概述
把类定义在其他类的内部，这个类就被称为内部类。
### 特点
* 内部类可以直接访问外部类的成员，包括私有
* 外部类要访问内部类的成员，必须创建对象
### 内部类位置
* 按照内部类在类中定义的位置不同，可以分为如下两种格式：
    * 成员位置(成员内部类)
    * 局部位置(局部内部类)
### 匿名内部类
* 前提：存在一个类或者接口，这里的类可以是具体类也可以是抽象类。
* 格式：new 类名或者接口名() {重写方法;}
* 本质：是一个继承了类或者实现了接口的子类匿名对象












